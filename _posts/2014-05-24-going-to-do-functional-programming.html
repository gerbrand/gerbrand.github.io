---
layout: post
title: Going to do functional programming
date: 2014-05-24 23:01:38.000000000 +02:00
type: post
published: true
status: publish
categories:
- Ideas
- Methodology
tags:
- haskell
- java
- scala
meta:
  _edit_last: '2'
  _responsive_layout: default
  _publicize_twitter_user: "@gerbrandvd"
  _wpas_done_all: '1'
  dsq_thread_id: '3768853465'
  _jetpack_related_posts_cache: a:0:{}
author:
  login: admin
  email: gerbrand@vandieijen.nl
  display_name: gerbrand
  first_name: Gerbrand
  last_name: van Dieijen
---
<p>I've learned about functional programming during my university years, with <a href="http://www.haskell.org/">Haskell</a> as primary language. I considered functional programming as quite elegant, but also impractical. I felt I could get practical results more quickly when using Java or C# than using Haskell. Sometimes I used functional constructs like immutability, separating action from calculation or transforming and trying to limit the side-effects of functions. Usually this ended up in remarks from colleagues, ranging from 'just accept java isn't functional' to 'I don't understand this code'.</p>
<p>Older, and more experienced at, and sometimes wearied of,software development, I'm getting to change my mind about how practical functional programming, as well as the inpractactically of object-oriented programming.</p>
<p>Some insights:</p>
<ul>
<li>Distributed software, SOA, services get much more understandable with functional patterns rather than with  <a href="http://www.quora.com/Object-Oriented-Programming/Was-object-oriented-programming-a-failure/answer/Michael-O-Church?srid=ukQ4&amp;share=1">object-oriented</a> patterns. What if you have to call multiple services, where each call depends on the result of another service? You don't want to block your software while doing a service-call? And how do you handle errors? What to do about <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">nullpointerexceptions</a>? Using<a href="https://www.youtube.com/watch?v=kZpLmcgq82k"> reactive programming</a> allows you to handle these problems a lot easier, and then you start doing<a href="http://www.infoq.com/presentations/covariance-contravariance-joy-of-coding-2014"> functional programming</a> already .</li>
<li>Software-architects like to split up software in 'layers'. When using an object oriented language, this leads to translation of objects living in one layer to objects living in another layer, to avoid objects having behavior that belong in one layer ending up in another layer: like persistable domain objects ending up in the UI-layer or business-logic in a service-layer. I am quite fed up with yet another <a href="http://dozer.sourceforge.net/">Dozer</a> implementation. And xslt almost looks like a<a href="http://stackoverflow.com/questions/110031/is-xslt-a-functional-programming-language"> functional programming</a> language, with a very verbose syntax.<br />
Instead of discussing what belongs in which layer and wetter or not a domain-object should be <a href="http://www.martinfowler.com/bliki/AnemicDomainModel.html">anemic</a> or not: lets separate behavior, data and logic altogether. Functional programming languages allow that more naturally and readable.</li>
<li>Reusability is often desired. Lots of reusable components are created at many companies. Rarely they're used. Software that is reused most successfully consists mostly just of a set of functions, having little or no state.<br />
I rather have a function <a href="http://rosettacode.org/wiki/IBAN#Haskell">validIban</a> then a class BankAccount with some method <a href="http://stackoverflow.com/questions/14256877/should-method-names-be-easy-to-remember">setIban</a> or worse that may throw a validation error and a whole lot of other methods I don't want.</li>
<li>When enterprise-system, software grows, so grows the complexity. Nowadays people try to handle the complexity by adding testers, architects, functional/business analysts, information analyst, requirement engineering, ESB, SOA, <a href="http://www.slideshare.net/ewolff/java-application-servers-are-dead">middleware</a> etc. <a href="https://medium.com/message/81e5f33a24e1">All in vain</a>, bugs still occur and software becomes unmaintainable legacy quickly, adding the need to add yet another software system.<br />
To truly handle software complexity, software must be of high quality and written in a <a href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/">highly expressive language</a>.<br />
Failed releases, software caused system-outages and software bug related security-flaws should not be considered a given we have to live by. <a href="https://plus.google.com/events/ci2g23mk0lh9too9bgbp3rbut0k">TDD</a> or automatic tests (not the same), clean-code, continuous deployment and similar practices may help. In the end I think a functional, pure, language may be our only hope.</li>
</ul>
<p>My goal will be for the coming year to both use and<a href="http://learnyouahaskell.com/"> learn functional programming</a> (fp) a lot more, explain it to other people and hope to popularize fp or ride the wave when functional-programming becomes more popular.</p>
<p>More bold, or maybe foolish, I take up my personal challenge to create something practically useful in <a href="http://learnyouahaskell.com/">Haskell</a>.</p>
